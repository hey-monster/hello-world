1、 Android JNI 原理分析
2、 Android 系统框架
3、HIDL

HIDL简介
HIDL 是用于指定 HAL 与其用户之间接口的一个接口描述语言（Interface Description Language），
它允许将指定的类型与函数调用收集到接口（Interface）和包（Package）中。
更广泛地说，HIDL 是一个可以让那些独立编译的代码库（Libraries）之间进行通信的系统。 
HIDL 实际上是用于进行进程间通信（Inter-process Communication，IPC）的。进程间的通信可以称为 Binder 化（Binderized）。
对于必须连接到进程的库，也可以使用 passthough 模式（但在Java中不支持）。 
HIDL 将指定的数据结构与方法签名组织到接口中，这些接口又会被收集到包中以供使用。
它的语法与 C++、JAVA 是类似的，不过关键字集合不尽相同。其注释风格与 JAVA 是一致的。

HIDL设计
设计 HIDL 这个机制的目的，主要是想把框架（framework）与 HAL 进行隔离，使得框架部分可以直接被覆盖、更新，
而不需要重新对 HAL 进行编译。HAL 的部分将会放在设备的 /vendor 分区中，并且是由设备供应商（vendors）或 SOC 制造商来构建。
这使得框架部分可以通过 OTA 方式更新，同时不需要重新编译 HAL。
4、音频概念
帧（frame）的概念：帧表示一个完整的声音单元，所谓的声音单元是指一个采样样本；如果是双声道，那么一个完整的声音单元就是 2 个样本，如果是 5.1 声道，那么一个完整的声音单元就是 6 个样本了。帧的大小（一个完整的声音单元的数据量）等于声道数乘以采样深度，即 frameSize = channelCount * bytesPerSample。帧的概念非常重要，无论是框架层还是内核层，都是以帧为单位去管理音频数据缓冲区的。

传输延迟（latency）的概念：传输延迟表示一个周期的音频数据的传输时间。可能有些读者一脸懵逼，一个周期的音频数据，这又是啥？我们再引入周期（period）的概念：Linux ALSA 把数据缓冲区划分为若干个块，dma 每传输完一个块上的数据即发出一个硬件中断，cpu 收到中断信号后，再配置 dma 去传输下一个块上的数据；一个块即是一个周期，周期大小（periodSize)即是一个数据块的帧数。再回到传输延迟（latency），传输延迟等于周期大小除以采样率，即 latency = periodSize / sampleRate。

音频重采样：音频重采样是指这样的一个过程——把一个采样率的数据转换为另一个采样率的数据。Android 原生系统上，音频硬件设备一般都工作在一个固定的采样率上（如 48 KHz），因此所有音轨数据都需要重采样到这个固定的采样率上，然后再输出。为什么这么做？系统中可能存在多个音轨同时播放，而每个音轨的采样率可能是不一致的；比如在播放音乐的过程中，来了一个提示音，这时需要把音乐和提示音混音并输出到硬件设备，而音乐的采样率和提示音的采样率不一致，问题来了，如果硬件设备工作的采样率设置为音乐的采样率的话，那么提示音就会失真；因此最简单见效的解决方法是：硬件设备工作的采样率固定一个值，所有音轨在 AudioFlinger 都重采样到这个采样率上，混音后输出到硬件设备，保证所有音轨听起来都不失真。

5、Android C++的sp指针
智能指针是c++ 中的一个概念，因为c++ 本身不具备垃圾回收机制，而且指针也不具备构造函数和析构函数，所以为了实现内存( 动态存储区) 的安全回收，必须对指针进行一层封装，而这个封装就是智能指针，
c++的智能指针有很多实现方式，有auto_ptr ,  unique_ptr , shared_ptr 三种，还有其他的。
android 中的sp 句柄类实际上就是google 实现的一种强引用的智能指针。

Android 中封装了sp<> 强指针，wp<>弱指针的操作。
1 .   强指针与一般意义的智能指针概念相同，通过引用计数来记录有多少使用者在使用一个对象，
         如果所有使用者都放弃了对该对象的引用，则该对象将被自动销毁。
2  .  弱指针也指向一个对象，但是弱指针仅仅记录该对象的地址，不能通过弱指针来访问该对象，
         也就是说不能通过弱智真来调用对象的成员函数或访问对象的成员变量。（这里不讨论弱指针，仅讨论强指针）
智能指针的实现原理可以看   http://blog.csdn.net/u014485786/article/details/51202757
